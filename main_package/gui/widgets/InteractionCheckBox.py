import typing
import numpy as np
from PyQt5 import QtCore
from PyQt5.QtWidgets import QWidget, QCheckBox, QLineEdit, QVBoxLayout, QLabel, QHBoxLayout, QLayout, QSizePolicy

from main_package.gui import GlobalStyle
from main_package.simulation.DemoSetter import FrozenMultiset
from main_package.simulation.Interaction import LeapfroggableInteraction


class CustomCheckBox(QWidget):
    """CheckBox whose label supports rich text. Holds the text lambda*Phi_A*Phi_A..."""

    stateChanged = QtCore.pyqtSignal()

    # The argument add_stretch_at_the_end is only needed for the interaction checkboxes to push them to the left.
    # It is set False when this widget is used for the 3D checkbox in ui.py
    def __init__(self, text: str, add_stretch_at_the_end: bool = True):
        super().__init__()
        RED = f'background-color: rgba{GlobalStyle.RED};'
        GREEN = f'background-color: rgba{GlobalStyle.GREEN};'

        self._checkBox = QCheckBox()
        self._checkBox.setStyleSheet(RED)
        self._checkBox.setMaximumWidth(20)
        def relay():
            if self._checkBox.isChecked():
                self._checkBox.setStyleSheet(GREEN)
            else:
                self._checkBox.setStyleSheet(RED)
            self.stateChanged.emit()
        self._checkBox.stateChanged.connect(relay)

        self._label = QLabel(text)
        self._label.setStyleSheet('font-size: 17pt')
        # Fixes the size of the label to the minimum size while all its contents are still visible
        self._label.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)
        # Uncomment the following line to make the background of the label visible. Useful to see what area the label actually occupies.
        # self._label.setStyleSheet("QLabel {background-color: red;}")

        layout = QHBoxLayout()
        layout.addWidget(self._checkBox)
        layout.addWidget(self._label)
        if add_stretch_at_the_end:
            layout.addStretch()

        self.setLayout(layout)

    def setChecked(self, state: bool) -> None:
        self._checkBox.setChecked(state)

    def isChecked(self) -> bool:
        return self._checkBox.isChecked()




class InteractionCheckBox(QWidget):
    """
    Handles an interaction parameter e.g. lambda_AC
    """
    signal_value_changed = QtCore.pyqtSignal(float)

    def __init__(self, on: bool,
                 default_value: float,
                 current_value: typing.Optional[float] = None,
                 identifier: typing.Optional[str] = None,
                 interaction: typing.Optional[LeapfroggableInteraction] = None,
                 frozenmultiset: typing.Optional[FrozenMultiset] = None,
                 make_equation: bool = None):
        """
        This contructor should be private and therefore not be called from outside. Instead, the classmethods below should
        be used.

        :param on: True if the checkBox should be initially turned on
        :param default_value: The default value of the interaction parameter lambda. By storing this, we can always
        reset the interaction term to its default value.
        :param current_value: The value that should be initially displayed in the checkBox.
        :param identifier: A string which uniquely identifies this checkBox. For an interaction checkbox, this is
        generated by FrozenMultiset. For the dt box, this is just the string the label displays.
        :param interaction: The interaction object that is used in the back-end simulation. It's useful to keep a
        reference to it here. If this class is instantiated as a dt checkBox, this argument will be None.
        :param frozenmultiset: The FrozenMultiset object which uniquely identifies an interaction term. If this class is
        instantiated as a dt checkBox, this will be None.
        :param make_equation: True if this class is to be instantiated as a dt checkBox. False if this class is to be
        instantiated as an interaction term checkBox.
        """

        super().__init__()

        self._frozenmultiset = frozenmultiset
        self._current_on = on
        self._default_on = on if frozenmultiset is None else frozenmultiset.get_on()
        self._default_value = default_value
        self._current_value = current_value
        self._identifier = identifier
        self._interaction = interaction

        # Checkbox
        # If this class is instantiated as an interaction term checkBox, i.e. make_equation==True, make a 'nice' label.
        # Otherwise (i.e. if this class is instantiated as a dt checkBox) just use the identifier, which will be 'greek delta'+'t'
        self._cb = CustomCheckBox(self._make_string(frozenmultiset) if make_equation else self._identifier)
        self._cb.setChecked(self._current_on)
        self._cb.stateChanged.connect(self.value_changed)

        # Text field
        self._tex = QLineEdit()
        self._matchTexToState()
        self._tex.editingFinished.connect(self.text_changed)

        self._layout = QVBoxLayout()
        self._layout.addWidget(self._cb)
        self._layout.addWidget(self._tex)
        self.setLayout(self._layout)

        # Keep the size of this widget fixed to its initial minimum size
        self.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)

        # width is measured in characters. Convert to pixels by width * 50, where 50 has been obtained empirically. Add 20 because of the small checkbox on the left.
        # width = self.fontMetrics().boundingRect(self._label).width()
        # print(width)
        # self.setMaximumSize(width, 100)
        # self.setMaximumSize(width * 50 + 20,100)
        # self.setMaximumHeight(100)

    # def getValueIfOn(self):
    #     return self._current_value if self._current_on else 0
    #
    # # Note this does not change the on/off state!
    # def setVal(self, val: float):
    #     self._current_value = val
    #     if (self._tex is not None) and (self._current_value != val):
    #         self._matchTexToState()
    #

    # TODO: Instead of using class methods (=overloading the contructor), this should use inheritance instead
    @classmethod
    def create_for_interaction_term(cls, on: bool, current_value: float, frozenmultiset: FrozenMultiset, interaction: LeapfroggableInteraction):
        """Creates an object as an interaction term checkBox."""
        return cls(on=on,
                default_value=interaction.get_parameter(),
                current_value=current_value,
                identifier=frozenmultiset.get_name(),
                interaction=interaction,
                frozenmultiset=frozenmultiset,
                make_equation=True)

    @classmethod
    def create_for_dt(cls, on: bool, value: float, label: str):
        """Creates an object as a dt checkBox."""
        return cls(on=on,
                default_value=value,
                current_value=value,
                identifier=label,
                make_equation=False)

    @staticmethod
    def _make_string(frozenmultiset: FrozenMultiset) -> str:
        """
        Qt supports rich text in a QLabel. See: https://doc.qt.io/qt-5/richtext-html-subset.html
        Creates a nicely formatted rich-text string which is used as a label for the interaction term checkBox.
        :param frozenmultiset: The FrozenMultiset object which uniquely identifies the interaction term.
        """

        names: list[str] = frozenmultiset.distinct_items()
        exponents: list[int] = frozenmultiset.frequencies()

        # Small greek lambda using unicode
        # lam: str = b'\xf0\x9d\x9d\x80'.decode()
        lam: str= b'\xce\xbb'.decode()
        # Small greek phi using unicode
        # phi: str = b'\xf0\x9d\x9c\x99'.decode()
        phi: str = b'\xcf\x86'.decode()

        res: str = lam + ' '
        for name, exponent in zip(names, exponents):
            name = name[0] # Use first letter of each name
            exponent = '' if exponent == 1 else exponent # write x^1 as x
            res += phi
            res += f'<sub>{name}</sub><sup>{exponent}</sup> '

        res = f'<html>\
                        <head>\
                            <title></title>\
                        </head>\
                        <body>\
                            <p style="font-size: 17pt">\
                                {res}\
                            </p>\
                        </body>\
                    </html>'
        return res

    def _matchTexToState(self):
        self.getTextField().setText(np.format_float_positional(self._current_value))

    def getTextField(self):
        return self._tex

    def getInitialOnState(self) -> bool:
        return self._current_on

    def get_identifier(self) -> str:
        return self._identifier

    def get_current_value(self) -> float:
        return self._current_value

    def get_default_value(self) -> float:
        return self._default_value

    def text_changed(self):
        keepOldNumber: bool = False
        newVal: float = 0

        try:
            newVal = float(self._tex.text())
        except ValueError:
            keepOldNumber = True

        if keepOldNumber:
            # keep old val
            self._matchTexToState()
        else:
            self._current_value = newVal
            self.value_changed()

    def value_changed(self):
        self._current_on = self._cb.isChecked()

        # Update the value in the frozenmultiset because the value stored in the frozenmultiset is used in the
        # initialconditioner (in InitialConditioner.py) to get the value currently displayed in the GUI.
        if self._frozenmultiset is not None:
            self._frozenmultiset.set_on(self._current_on)

        if self._current_on:
            self.signal_value_changed.emit(self._current_value)
        else:
            self.signal_value_changed.emit(0.0)

    def reset_to_default_value(self) -> None:
        self._current_value = self._default_value
        self._current_on = self._default_on

        # Update the value in the frozenmultiset because the value stored in the frozenmultiset is used in the
        # initialconditioner (in InitialConditioner.py) to get the value currently displayed in the GUI.
        if self._frozenmultiset is not None:
            self._frozenmultiset.set_on(self._current_on)

        self._cb.setChecked(self._current_on)
        self.value_changed()
        self._matchTexToState()


class InteractionCheckBoxLayout(QVBoxLayout):
    '''
    This class manages the objects of type InteractionCheckBox.
    It adds widgets to the layout before the stretch.
    '''

    def __init__(self):
        super().__init__()
        # Add a stretch to push all checkBoxes upwards so that they sit 'nice and tight'.
        self.addStretch()

    def addWidget(self, a0: QWidget, stretch: int = ..., alignment: typing.Union[QtCore.Qt.Alignment, QtCore.Qt.AlignmentFlag] = ...) -> None:
        """Override this method to add a widget before the stretch (instead of after the stretch)."""
        self.insertWidget(self.count() - 1, a0)